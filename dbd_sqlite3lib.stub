"
#include <gauche/class.h>
#include <gauche/bignum.h>
#include <gauche/uvector.h>

#include <sqlite3.h>
"

(declcode (.include  "gauche_dbd_sqlite3.h"))

(declcode "
ScmClass *Sqlite3DbClass;
ScmClass *Sqlite3StmtClass;
")

(initcode
  (set! Sqlite3DbClass (Scm_MakeForeignPointerClass
						mod "<sqlite3-db>" NULL
						db-finalize 0))
  (set! Sqlite3StmtClass (Scm_MakeForeignPointerClass
						  mod "<sqlite3-statement>" NULL
						  stmt-finalize 0)))

(define-type <sqlite3-db> "ScmSqlite3Db *" #f
  "SCM_SQLITE3_DB_P" "SQLITE3_DB_HANDLE_UNBOX" "SQLITE3_DB_HANDLE_BOX")

(define-type <sqlite3-statement> "ScmSqlite3Stmt *" #f
  "SCM_SQLITE3_STMT_P" "SQLITE3_STMT_HANDLE_UNBOX" "SQLITE3_STMT_HANDLE_BOX")

;; (define-cproc bind-sqlite-parameters (stmt::<sqlite3-statement> params::<list>)
;;   (expr <sqlite3-statement> "Sqlite3StmtBind(stmt, params)"))

;; (define-cproc sqlite3-reset-statement (stmt::<sqlite3-statement>) :: <void>
;;   (sqlite3_reset (-> stmt core)))

(define-cfn check-db (db::ScmSqlite3Db*)
  :: void :static
  (when (-> db terminated)
    (Scm_Error "<sqlite3-db> already closed")))

(define-cfn check-statement (stmt::ScmSqlite3Stmt*)
  :: void :static
  (unless (-> stmt executed)
	(Scm_Error "<sqlite3-statement> not executed yet"))
  (when (-> stmt terminated)
	(Scm_Error "<sqlite3-statement> already closed")))

(define-cfn prepare-statement (db::ScmSqlite3Db* sql::(const char*) stmt::ScmSqlite3Stmt*)
  :: int :static
  (let* ([handle::sqlite3_stmt* NULL]
         [tail::(const char*)])
    (unless (== (sqlite3_prepare_v2 (-> db core) sql -1 (& handle) (& tail)) SQLITE_OK)
      (return FALSE))
    (set! (-> stmt core) handle)
    (set! (-> stmt tail) tail)
    (return TRUE)))

(define-cfn sqlite3-db-finalize (db::ScmSqlite3Db*)
  :: int :static
  (cond
   [(== (-> db core) NULL)
	(return FALSE)]
   [else
    ;; TODO  check return value
	(sqlite3_close (-> db core))
	(set! (-> db core) NULL)
	(set! (-> db terminated) TRUE)
	(return TRUE)]))

(define-cfn sqlite3-stmt-finalize (stmt::ScmSqlite3Stmt*)
  :: int :static
  (cond
   [(== (-> stmt core) NULL)
    (return FALSE)]
   [else
    ;; TODO  check return value
    (sqlite3_finalize (-> stmt core))
    (set! (-> stmt core) NULL)
    (return TRUE)]))

(define-cfn db-finalize (obj::ScmObj)
  :: void :static
  (SCM_ASSERT (SCM_FOREIGN_POINTER_P obj))
  (let* ([db::ScmSqlite3Db* (SQLITE3_DB_HANDLE_UNBOX obj)])
	(sqlite3-db-finalize db)))

(define-cfn stmt-finalize (obj::ScmObj)
  :: void :static
  (SCM_ASSERT (SCM_FOREIGN_POINTER_P obj))
  (let* ([stmt::ScmSqlite3Stmt* (SQLITE3_STMT_HANDLE_UNBOX obj)])
	(sqlite3-stmt-finalize stmt)))

(define-cfn make-row-vector (stmt::ScmSqlite3Stmt*)
  :: ScmObj :static
  (let* ([i::(unsigned int)]
		 [num::(unsigned int) (sqlite3_column_count (-> stmt core))]
		 [res::ScmObj (Scm_MakeVector num SCM_FALSE)]
		 [value::ScmObj])
	(for ((set! i 0) (< i num) (pre++ i))
		 (let* ([type::int (sqlite3_column_type (-> stmt core) i)])
		   (case type
			[(SQLITE_INTEGER)
			 (set! value (Scm_MakeBignumFromSI (sqlite3_column_int64 (-> stmt core) i)))]
			[(SQLITE_FLOAT)
			 (set! value (Scm_MakeFlonum (sqlite3_column_double (-> stmt core) i)))]
			[(SQLITE_TEXT)
			 (set! value (SCM_MAKE_STR_COPYING (sqlite3_column_text (-> stmt core) i)))]
			[(SQLITE_BLOB)
			 (set! value (Scm_MakeU8VectorFromArray
						  ;; size of blob
						  (sqlite3_column_bytes (-> stmt core) i)
						  (cast (unsigned char *) (sqlite3_column_blob (-> stmt core) i))))]
			[(SQLITE_NULL)
			 (set! value SCM_FALSE)]
			[else
			 (Scm_Error "unknown sqlite3_column_type")]))
		 (Scm_VectorSet (SCM_VECTOR res) i value))

    (return res)))

(define-cproc sqlite3-make-statement () :: <sqlite3-statement>
  (let* ([stmt::ScmSqlite3Stmt* (SCM_MALLOC(sizeof(ScmSqlite3Stmt)))])
    (set! (-> stmt core) NULL)
    (set! (-> stmt executed) FALSE)
    (set! (-> stmt terminated) FALSE)
    (result stmt)))

(define-cproc sqlite3-db-close (db::<sqlite3-db>) :: <boolean>
  (result (sqlite3-db-finalize db)))

(define-cproc sqlite3-prepare (db::<sqlite3-db> stmt::<sqlite3-statement> sql::<string>) :: <boolean>
  (let* ([query::(const char*) (Scm_GetStringConst sql)])
    (check-db db)
    (cond
     [(prepare-statement db query stmt)
      (set! (-> stmt db) db)
      (set! (-> stmt executed) TRUE)
      (set! (-> stmt terminated) FALSE)
      (result TRUE)]
     [else
      (result FALSE)])))

(define-cproc sqlite3-open (path::<string>) :: <sqlite3-db>
  (let* ([db::ScmSqlite3Db* (SCM_MALLOC(sizeof(ScmSqlite3Db)))])
    (unless (== (sqlite3_open (Scm_GetString path) (& (-> db core))) SQLITE_OK)
      (Scm_Error "OPEN ERROR"))
    (set! (-> db terminated) FALSE)
    (result db)))

(define-cproc sqlite3-escape-string (value::<string>)
  (let*  ([tmp::char* (sqlite3_mprintf "%q" (Scm_GetStringConst value))]
          [res::ScmObj (SCM_MAKE_STR_COPYING tmp)])

    (sqlite3_free tmp)
    (result res)))

(define-cproc sqlite3-errmsg (db::<sqlite3-db>) :: <const-cstring>
  (result (sqlite3_errmsg (-> db core))))

(define-cproc sqlite3-last-insert-rowid (db::<sqlite3-db>) :: <ulong>
  (sqlite3_last_insert_rowid (-> db core)))

(define-cproc sqlite3-statement? (obj) :: <boolean>
  (result (SCM_SQLITE3_STMT_P obj)))

(define-cproc sqlite3-closed? (db::<sqlite3-db>) :: <boolean>
  (result (-> db terminated)))

(define-cproc sqlite3-statement-end? (stmt::<sqlite3-statement>) :: <boolean>
  (result (-> stmt terminated)))

(define-cproc sqlite3-statement-step (stmt::<sqlite3-statement>)
  (let* ([rc::int])
	(check-statement stmt)
    (set! rc (sqlite3_step (-> stmt core)))

	;;TODO test.scm all path of this code block

	(case rc
	  [(SQLITE_ROW)
	   ;; returned from SELECT statement
	   (result (make-row-vector stmt))]
	  [(SQLITE_DONE)
	   ;; returned from NO result set.
	   ;; continue until result set is returned.

	   ;; /* TODO  */
	   ;; /* multiple SELECT statement */

	   ;; stmt->tail has rest of multiple statements.
	   (while (and (-> stmt tail) (* (-> stmt tail)))
		 (unless (prepare-statement (-> stmt db) (-> stmt tail) stmt)
		   (Scm_Error "sqlite3_prepare_v2 failed while handling compound statement."))

		 (while TRUE
		   (set! rc (sqlite3_step (-> stmt core)))
		  
		   (when (== rc SQLITE_ROW)
			 (return (make-row-vector stmt)))

		   ;;TODO 3 UPDATE statement. -> stmt terminated is wrong?
		   (when (== rc SQLITE_DONE)
			 (break))

		   (Scm_Error "sqlite3_step failed: %d" rc)))

	   (set! (-> stmt terminated) TRUE)
	   (result SCM_FALSE)]
	  [else

	   ;; http://www.sqlite.org/c3ref/c_abort.html
	   (Scm_Error "sqlite3_step failed: %d" rc)])))

(define-cproc sqlite3-statement-closed? (stmt::<sqlite3-statement>) :: <boolean>
  (let* ([handle::sqlite3_stmt* (-> stmt core)])
    (result (== handle NULL))))

(define-cproc sqlite3-db-finish (db::<sqlite3-db>) :: <boolean>
  (result (sqlite3-db-finalize db)))

(define-cproc sqlite3-statement-close (stmt::<sqlite3-statement>) :: <boolean>
  (result (sqlite3-stmt-finalize stmt)))

(define-cproc sqlite3-statement-column-names (stmt::<sqlite3-statement>)
  (let* ([num::int (sqlite3_column_count (-> stmt core))]
         [i::int]
         [res '()])
    (for ((set! i 0) (< i num) (pre++ i))
         (let* ([val (SCM_MAKE_STR_COPYING (sqlite3_column_name (-> stmt core) i))])
           (set! res (Scm_Cons val res))))
    (set! res (Scm_Reverse res))
    (result res)))



