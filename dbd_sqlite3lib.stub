"
#include <gauche/bignum.h>

#include <sqlite3.h>
"

(declcode (.include  "gauche_dbd_sqlite3.h"))

(initcode
 (set! Sqlite3DbClass (Scm_MakeForeignPointerClass
                       mod "<sqlite3-db>" NULL
                       db-finalize 0))
 (set! Sqlite3StmtClass (Scm_MakeForeignPointerClass
                         mod "<sqlite3-statement>" NULL
                         stmt-finalize 0)))

(define-type <sqlite3-db> "ScmSqlite3Db *" #f
  "SCM_SQLITE3_DB_P" "SQLITE3_DB_HANDLE_UNBOX" "SQLITE3_DB_HANDLE_BOX")

(define-type <sqlite3-statement> "ScmSqlite3Stmt *" #f
  "SCM_SQLITE3_STMT_P" "SQLITE3_STMT_HANDLE_UNBOX" "SQLITE3_STMT_HANDLE_BOX")

;; (define-cproc bind-sqlite-parameters (stmt::<sqlite3-statement> params::<list>)
;;   (expr <sqlite3-statement> "Sqlite3StmtBind(stmt, params)"))

;; (define-cproc sqlite3-reset-statement (stmt::<sqlite3-statement>) :: <void>
;;   (sqlite3_reset (-> stmt core)))

;;;
;;; C functions
;;;

(define-cfn check-db (db::ScmSqlite3Db*)
  :: void :static
  (when (-> db terminated)
    (Scm_Error "<sqlite3-db> already closed")))

(define-cfn check-statement (stmt::ScmSqlite3Stmt*)
  :: void :static
  (unless (-> stmt executed)
    (Scm_Error "<sqlite3-statement> not executed yet"))
  (when (-> stmt terminated)
    (Scm_Error "<sqlite3-statement> already closed")))

(define-cfn prepare-statement (db::ScmSqlite3Db* sql::(const char*) stmt::ScmSqlite3Stmt*)
  :: void :static
  (let* ([handle::sqlite3_stmt* NULL]
         [tail::(const char*)])
    (unless (== (sqlite3_prepare_v2 (-> db core) sql -1 (& handle) (& tail)) SQLITE_OK)
      (Scm_Error "Failed to prepare statement (%s)" (sqlite3_errmsg (-> db core))))
    (set! (-> stmt core) handle)
    (set! (-> stmt tail) tail)))

(define-cfn db-close (db::ScmSqlite3Db*)
  :: int :static
  (cond
   [(== (-> db core) NULL)
    (return FALSE)]
   [else
    ;; TODO  check return value
    (sqlite3_close (-> db core))
    (set! (-> db core) NULL)
    (set! (-> db terminated) TRUE)
    (return TRUE)]))

(define-cfn stmt-close (stmt::ScmSqlite3Stmt*)
  :: int :static
  (cond
   [(== (-> stmt core) NULL)
    (return FALSE)]
   [else
    ;; TODO check return value
    (sqlite3_finalize (-> stmt core))
    (set! (-> stmt core) NULL)
    (return TRUE)]))

(define-cfn db-finalize (obj::ScmObj)
  :: void :static
  (SCM_ASSERT (SCM_FOREIGN_POINTER_P obj))
  (let* ([db::ScmSqlite3Db* (SQLITE3_DB_HANDLE_UNBOX obj)])
    (db-close db)))

(define-cfn stmt-finalize (obj::ScmObj)
  :: void :static
  (SCM_ASSERT (SCM_FOREIGN_POINTER_P obj))
  (let* ([stmt::ScmSqlite3Stmt* (SQLITE3_STMT_HANDLE_UNBOX obj)])
    (stmt-close stmt)))

(define-cfn make-row-vector (stmt::ScmSqlite3Stmt*)
  :: ScmObj :static
  (let* ([i::(unsigned int)]
         [num::(unsigned int) (sqlite3_column_count (-> stmt core))]
         [res::ScmObj (Scm_MakeVector num SCM_FALSE)]
         [value::ScmObj])
    (for ((set! i 0) (< i num) (pre++ i))
         (let* ([type::int (sqlite3_column_type (-> stmt core) i)])
           (case type
             [(SQLITE_INTEGER)
              (set! value (Scm_MakeBignumFromSI (sqlite3_column_int64 (-> stmt core) i)))]
             [(SQLITE_FLOAT)
              (set! value (Scm_MakeFlonum (sqlite3_column_double (-> stmt core) i)))]
             [(SQLITE_TEXT)
              (set! value (SCM_MAKE_STR_COPYING (sqlite3_column_text (-> stmt core) i)))]
             [(SQLITE_BLOB)
              (set! value (Scm_MakeU8VectorFromArray
                           ;; size of blob
                           (sqlite3_column_bytes (-> stmt core) i)
                           (cast (unsigned char *) (sqlite3_column_blob (-> stmt core) i))))]
             [(SQLITE_NULL)
              (set! value SCM_FALSE)]
             [else
              (Scm_Error "unknown sqlite3_column_type")]))
         (Scm_VectorSet (SCM_VECTOR res) i value))

    (return res)))

(define-cfn make-statement () :: ScmSqlite3Stmt* :static
  (let* ([stmt::ScmSqlite3Stmt* (SCM_MALLOC (sizeof ScmSqlite3Stmt))])
    (set! (-> stmt core) NULL)
    (set! (-> stmt executed) FALSE)
    (set! (-> stmt terminated) FALSE)
    (return stmt)))

;;;
;;; function call from scheme
;;;

(define-cproc sqlite3-open (path::<string>) :: <sqlite3-db>
  (let* ([db::ScmSqlite3Db* (SCM_MALLOC (sizeof ScmSqlite3Db))]
         [cpath::(const char*) (Scm_GetStringConst path)])
    (unless (== (sqlite3_open cpath (& (-> db core))) SQLITE_OK)
      (Scm_Error "Failed to open database %s" cpath))
    (set! (-> db terminated) FALSE)
    (result db)))

(define-cproc sqlite3-db-close (db::<sqlite3-db>) :: <boolean>
  (result (db-close db)))

(define-cproc sqlite3-db-closed? (db::<sqlite3-db>) :: <boolean>
  (result (-> db terminated)))

(define-cproc sqlite3-prepare (db::<sqlite3-db> sql::<string>)
  :: <sqlite3-statement>
  (let* ([stmt::ScmSqlite3Stmt* (make-statement)]
		 [query::(const char*) (Scm_GetStringConst sql)])
    (check-db db)
	(prepare-statement db query stmt)
	(set! (-> stmt db) db)
	(set! (-> stmt executed) TRUE)
	(set! (-> stmt terminated) FALSE)
	(result stmt)))

(define-cproc sqlite3-statement? (obj) :: <boolean>
  (result (SCM_SQLITE3_STMT_P obj)))

(define-cproc sqlite3-statement-end? (stmt::<sqlite3-statement>) :: <boolean>
  (result (-> stmt terminated)))

(define-cproc sqlite3-statement-closed? (stmt::<sqlite3-statement>) :: <boolean>
  (let* ([handle::sqlite3_stmt* (-> stmt core)])
    (result (== handle NULL))))

(define-cproc sqlite3-statement-close (stmt::<sqlite3-statement>) :: <boolean>
  (result (stmt-close stmt)))

(define-cproc sqlite3-statement-step (stmt::<sqlite3-statement>)
  (let* ([rc::int])
	(check-statement stmt)

	(set! rc (sqlite3_step (-> stmt core)))
	;;TODO test.scm all path of this code block

	(case rc
	  [(SQLITE_ROW)
	   ;; returned from SELECT statement
	   (return (make-row-vector stmt))]
	  [(SQLITE_DONE)
	   ;; returned from NO result set.
	   ;; continue until result set is returned.

	   ;; /* TODO  */
	   ;; /* multiple SELECT statement */

	   ;; stmt->tail has rest of multiple statements.
	   (while (and (-> stmt tail) (* (-> stmt tail)))
		 (prepare-statement (-> stmt db) (-> stmt tail) stmt)

		 (set! rc (sqlite3_step (-> stmt core)))

		 (cond
		  [(== rc SQLITE_ROW)
		   (return (make-row-vector stmt))]
		  [(== rc SQLITE_DONE)
		   ;; Successfully finished non result statement.
		   ]
		  [else
		   (Scm_Error "sqlite3_step failed: %d" rc)]))

	   (set! (-> stmt terminated) TRUE)
	   (result SCM_FALSE)]
	  [else

	   ;; http://www.sqlite.org/c3ref/c_abort.html
	   (Scm_Error "sqlite3_step failed: %d" rc)])))

(define-cproc sqlite3-statement-column-names (stmt::<sqlite3-statement>)
  (let* ([num::int (sqlite3_column_count (-> stmt core))]
         [i::int]
         [res '()])
    (for ((set! i 0) (< i num) (pre++ i))
         (let* ([val (SCM_MAKE_STR_COPYING (sqlite3_column_name (-> stmt core) i))])
           (set! res (Scm_Cons val res))))
    (set! res (Scm_Reverse res))
    (result res)))

(define-cproc sqlite3-escape-string (value::<string>)
  (let*  ([tmp::char* (sqlite3_mprintf "%q" (Scm_GetStringConst value))]
          [res::ScmObj (SCM_MAKE_STR_COPYING tmp)])

    (sqlite3_free tmp)
    (result res)))

(define-cproc sqlite3-last-errmsg (db::<sqlite3-db>) :: <const-cstring>
  (result (sqlite3_errmsg (-> db core))))

(define-cproc sqlite3-last-insert-rowid (db::<sqlite3-db>) :: <ulong>
  (result (sqlite3_last_insert_rowid (-> db core))))


