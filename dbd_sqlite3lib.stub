"
#include <gauche/bignum.h>

#include <sqlite3.h>
"

(declcode (.include  "gauche_dbd_sqlite3.h"))

(initcode
 (set! Sqlite3DbClass (Scm_MakeForeignPointerClass
                       mod "<sqlite3-db>" NULL
                       db-finalize 0))
 (set! Sqlite3StmtClass (Scm_MakeForeignPointerClass
                         mod "<sqlite3-statement>" NULL
                         stmt-finalize 0)))

(define-type <sqlite3-db> "ScmSqlite3Db *" #f
  "SCM_SQLITE3_DB_P" "SQLITE3_DB_HANDLE_UNBOX" "SQLITE3_DB_HANDLE_BOX")

(define-type <sqlite3-statement> "ScmSqlite3Stmt *" #f
  "SCM_SQLITE3_STMT_P" "SQLITE3_STMT_HANDLE_UNBOX" "SQLITE3_STMT_HANDLE_BOX")

;;;
;;; C functions
;;;

(define-cfn check-db (db::ScmSqlite3Db*)
  :: void :static
  (when (-> db terminated)
    (Scm_Error "<sqlite3-db> already closed")))

(define-cfn check-statement (stmt::ScmSqlite3Stmt*)
  :: void :static
  (unless (-> stmt executed)
    (Scm_Error "<sqlite3-statement> not executed yet"))
  (when (-> stmt terminated)
    (Scm_Error "<sqlite3-statement> already closed")))

(define-cfn prepare-statement (db::ScmSqlite3Db* sql::(const char*) stmt::ScmSqlite3Stmt*)
  :: void :static
  (let* ([handle::sqlite3_stmt* NULL]
         [tail::(const char*)])
    (unless (== (sqlite3_prepare_v2 (-> db core) sql -1 (& handle) (& tail)) SQLITE_OK)
      (Scm_Error "Failed to prepare statement (%s)"
				 (sqlite3_errmsg (-> db core))))
    (set! (-> stmt core) handle)
    (set! (-> stmt tail) tail)))

(define-cfn db-close (db::ScmSqlite3Db*)
  :: int :static
  (cond
   [(== (-> db core) NULL)
    (return FALSE)]
   [else
	;; TODO cleanup all of unfinished statements?
    ;; (unless (== (sqlite3_close (-> db core)) SQLITE_OK)
	;;   (Scm_Error "Failed to close database (%s)"
	;; 			 (sqlite3_errmsg (-> db core))))
	(sqlite3_close (-> db core))
    (set! (-> db core) NULL)
    (set! (-> db terminated) TRUE)
    (return TRUE)]))

(define-cfn stmt-close (stmt::ScmSqlite3Stmt*)
  :: int :static
  (cond
   [(== (-> stmt core) NULL)
    (return FALSE)]
   [else
    (unless (== (sqlite3_finalize (-> stmt core)) SQLITE_OK)
	  (Scm_Error "Failed to close statement (%s)"
				 (sqlite3_errmsg (-> stmt db core))))
    (set! (-> stmt core) NULL)
    (return TRUE)]))

(define-cfn db-finalize (obj::ScmObj)
  :: void :static
  (SCM_ASSERT (SCM_FOREIGN_POINTER_P obj))
  (let* ([db::ScmSqlite3Db* (SQLITE3_DB_HANDLE_UNBOX obj)])
    (db-close db)))

(define-cfn stmt-finalize (obj::ScmObj)
  :: void :static
  (SCM_ASSERT (SCM_FOREIGN_POINTER_P obj))
  (let* ([stmt::ScmSqlite3Stmt* (SQLITE3_STMT_HANDLE_UNBOX obj)])
    (stmt-close stmt)))

(define-cfn bind-index-param (stmt::sqlite3_stmt* index::int value::ScmObj)
  :: void :static
  (cond
   [(or (SCM_INTP value)
		(SCM_BIGNUMP value))
	;; Not consider about overflow
	;; beyond the max/min value truncate to max/min int64 value
	(sqlite3_bind_int64 stmt index (Scm_GetInteger64 value))]
   [(SCM_REALP value)
	(sqlite3_bind_double stmt index (Scm_GetDouble value))]
   [(SCM_U8VECTORP value)
	(sqlite3_bind_blob stmt index (SCM_U8VECTOR_ELEMENTS value)
					   (SCM_U8VECTOR_SIZE value)
					   ;; keep allocated memory
					   SQLITE_STATIC)]
   [(SCM_STRINGP value)
	(sqlite3_bind_text stmt index (Scm_GetStringConst (SCM_STRING value))
					   (SCM_STRING_SIZE value)
					   ;; keep allocated memory
					   SQLITE_STATIC)]
   [(SCM_FALSEP value)
	(sqlite3_bind_null stmt index)]
   [else
	(Scm_Error "Not a supported scheme object")]))

(define-cfn bind-name-param (stmt::sqlite3_stmt* name::(const char*) value::ScmObj)
  :: void :static
  (let* ([index::int (sqlite3_bind_parameter_index stmt name)])
	(bind-index-param stmt index value)))

(define-cfn make-row-vector (stmt::ScmSqlite3Stmt*)
  :: ScmObj :static
  (let* ([i::(unsigned int)]
         [num::(unsigned int) (sqlite3_column_count (-> stmt core))]
         [res::ScmObj (Scm_MakeVector num SCM_FALSE)]
         [value::ScmObj])
    (for ((set! i 0) (< i num) (pre++ i))
         (let* ([type::int (sqlite3_column_type (-> stmt core) i)])
           (case type
             [(SQLITE_INTEGER)
              (set! value (Scm_MakeBignumFromSI (sqlite3_column_int64 (-> stmt core) i)))]
             [(SQLITE_FLOAT)
              (set! value (Scm_MakeFlonum (sqlite3_column_double (-> stmt core) i)))]
             [(SQLITE_TEXT)
              (set! value (SCM_MAKE_STR_COPYING (sqlite3_column_text (-> stmt core) i)))]
             [(SQLITE_BLOB)
              (set! value (Scm_MakeU8VectorFromArray
                           ;; size of blob
                           (sqlite3_column_bytes (-> stmt core) i)
                           (cast (unsigned char *) (sqlite3_column_blob (-> stmt core) i))))]
             [(SQLITE_NULL)
              (set! value SCM_FALSE)]
             [else
              (Scm_Error "unknown sqlite3_column_type (%d)" type)]))
         (Scm_VectorSet (SCM_VECTOR res) i value))

    (return res)))

(define-cfn make-statement () :: ScmSqlite3Stmt* :static
  (let* ([stmt::ScmSqlite3Stmt* (SCM_MALLOC (sizeof ScmSqlite3Stmt))])
    (set! (-> stmt core) NULL)
    (set! (-> stmt executed) FALSE)
    (set! (-> stmt terminated) FALSE)
    (return stmt)))

;;;
;;; function call from scheme
;;;

(define-cproc sqlite3-version ()  :: <const-cstring>
  (result (sqlite3_libversion)))

(define-cproc sqlite3-open (path::<string> flags::<int32>) :: <sqlite3-db>
  (let* ([db::ScmSqlite3Db* (SCM_MALLOC (sizeof ScmSqlite3Db))]
         [cpath::(const char*) (Scm_GetStringConst path)]
		 ;; sqlite3_open use this as flags.
		 [def_flags::int (logior SQLITE_OPEN_READWRITE SQLITE_OPEN_CREATE)])
    (unless (== (sqlite3_open_v2 cpath (& (-> db core))
								 (logior flags def_flags)
								 NULL) SQLITE_OK)
      (Scm_Error "Failed to open database %s" cpath))
    (set! (-> db terminated) FALSE)
    (result db)))

(define-cproc sqlite3-db-close (db::<sqlite3-db>) :: <boolean>
  (result (db-close db)))

(define-cproc sqlite3-db-closed? (db::<sqlite3-db>) :: <boolean>
  (result (-> db terminated)))

(define-cproc sqlite3-prepare (db::<sqlite3-db> sql::<string>)
  :: <sqlite3-statement>
  (let* ([stmt::ScmSqlite3Stmt* (make-statement)]
		 [query::(const char*) (Scm_GetStringConst sql)])
    (check-db db)
	(prepare-statement db query stmt)
	(set! (-> stmt db) db)
	(set! (-> stmt executed) TRUE)
	(set! (-> stmt terminated) FALSE)
	(result stmt)))

(define-cproc sqlite3-statement? (obj) :: <boolean>
  (result (SCM_SQLITE3_STMT_P obj)))

(define-cproc sqlite3-statement-end? (stmt::<sqlite3-statement>) :: <boolean>
  (result (-> stmt terminated)))

(define-cproc sqlite3-statement-closed? (stmt::<sqlite3-statement>) :: <boolean>
  (let* ([handle::sqlite3_stmt* (-> stmt core)])
    (result (== handle NULL))))

(define-cproc sqlite3-statement-close (stmt::<sqlite3-statement>) :: <boolean>
  (result (stmt-close stmt)))

(define-cproc sqlite3-statement-step (stmt::<sqlite3-statement>)
  (let* ([rc::int])
	(check-statement stmt)

	(set! rc (sqlite3_step (-> stmt core)))

	(case rc
	  [(SQLITE_ROW)
	   ;; returned from SELECT statement
	   (return (make-row-vector stmt))]
	  [(SQLITE_DONE)
	   ;; returned from NO result set.
	   ;; continue until result set is returned.

	   ;; stmt->tail has rest of multiple statements.
	   (while (and (-> stmt tail) (* (-> stmt tail)))
		 (prepare-statement (-> stmt db) (-> stmt tail) stmt)

		 (set! rc (sqlite3_step (-> stmt core)))

		 (cond
		  [(== rc SQLITE_ROW)
		   (return (make-row-vector stmt))]
		  [(== rc SQLITE_DONE)
		   ;; Successfully finished non result statement.
		   ]
		  [else
		   (Scm_Error "sqlite3_step failed: %s"
					  (sqlite3_errmsg (-> stmt db core)))]))

	   (set! (-> stmt terminated) TRUE)
	   (result SCM_FALSE)]
	  [else

	   ;; http://www.sqlite.org/c3ref/c_abort.html
	   (Scm_Error "sqlite3_step failed: %s"
				  (sqlite3_errmsg (-> stmt db core)))])))

(define-cproc sqlite3-statement-column-names (stmt::<sqlite3-statement>)
  (let* ([num::int (sqlite3_column_count (-> stmt core))]
         [i::int]
         [res '()])
    (for ((set! i 0) (< i num) (pre++ i))
         (let* ([val (SCM_MAKE_STR_COPYING (sqlite3_column_name (-> stmt core) i))])
           (set! res (Scm_Cons val res))))
    (set! res (Scm_Reverse res))
    (result res)))

(define-cproc sqlite3-bind-parameters (stmt::<sqlite3-statement> params::<list>)
  (let* ([handle::(sqlite3_stmt*) (-> stmt core)])
	;; may fail if stmt is being processed.
	(unless (== (sqlite3_reset handle) SQLITE_OK)
	  (Scm_Error "sqlite3_reset failed (%s)"
				 (sqlite3_errmsg (-> stmt db core))))
	(dolist (pair params)
	  (unless (SCM_PAIRP pair)
		(Scm_Error "Invalid params"))
	  (let* ([key::ScmObj (SCM_CAR pair)]
			 [value::ScmObj (SCM_CDR pair)])
		(cond
		 [(SCM_STRINGP key)
		  (bind-name-param handle (Scm_GetStringConst (SCM_STRING key)) value)]
		 [(SCM_UINTEGERP key)
		  (bind-index-param handle (Scm_GetIntegerU key) value)]
		 [else
		  (Scm_Error "Not a supported param key")])))))

(define-cproc sqlite3-escape-string (value::<string>)
  (let*  ([tmp::char* (sqlite3_mprintf "%q" (Scm_GetStringConst value))]
          [res::ScmObj (SCM_MAKE_STR_COPYING tmp)])

    (sqlite3_free tmp)
    (result res)))

(define-cproc sqlite3-last-errmsg (db::<sqlite3-db>) :: <const-cstring>
  (result (sqlite3_errmsg (-> db core))))

(define-cproc sqlite3-last-insert-rowid (db::<sqlite3-db>) :: <ulong>
  (result (sqlite3_last_insert_rowid (-> db core))))


