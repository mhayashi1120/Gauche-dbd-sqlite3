(initcode (.include  "gauche_dbd_sqlite3.h"))

(define-type <sqlite3-handle> "sqlite3 *" "sqlite3-handle"
  "SCM_SQLITE3_P" "SQLITE3_HANDLE_UNBOX" "SQLITE3_HANDLE_BOX")

(define-type <sqlite3-statement> "ScmSqlite3Stmt *" "sqlite3-statement-handle"
  "SCM_SQLITE3_STMT_P" "SQLITE3_STMT_HANDLE_UNBOX" "SQLITE3_STMT_HANDLE_BOX")

;; (define-cproc bind-sqlite-parameters (stmt::<sqlite3-statement> params::<list>)
;;   (expr <sqlite3-statement> "Sqlite3StmtBind(stmt, params)"))

;; (define-cproc sqlite3-reset-statement (stmt::<sqlite3-statement>) :: <void>
;;   (sqlite3_reset (-> stmt core)))

(define-cproc make-sqlite-statement () :: <sqlite3-statement>
  (let* ([stmt::ScmSqlite3Stmt* (SCM_MALLOC(sizeof(ScmSqlite3Stmt)))])
	(set! (-> stmt core) NULL)
	(set! (-> stmt executed) 0)
	(set! (-> stmt terminated) 0)
	(result stmt)))

(define-cproc sqlite3-close (db::<sqlite3-handle>)
  (expr <boolean> "Sqlite3DbClose(db_scm)"))

(define-cfn check-db (db::sqlite3*)
  :: void :static
  ;;TODO
  ;; (when (sqlite3-closed-p db)
  ;; 	(Scm_Error "<sqlite3-handle> already closed"))
  )

(define-cfn prepare-statement (db::sqlite3* sql::(const char*) stmt::ScmSqlite3Stmt*)
  :: int :static
  (let* ([handle::sqlite3_stmt* NULL]
         [tail::(const char*)])
    (unless (== (sqlite3_prepare_v2 db sql -1 (& handle) (& tail)) SQLITE_OK)
      (return FALSE))
    (set! (-> stmt core) handle)
    (set! (-> stmt tail) tail)
    (return TRUE)))

(define-cproc sqlite3-prepare (db::<sqlite3-handle> stmt::<sqlite3-statement> sql::<string>) :: <boolean>
  (let* ([query::(const char*) (Scm_GetStringConst sql)])
	(check-db db)
	(cond
	 [(== (prepare-statement db query stmt) 0)
	  (result FALSE)]
	 [else
	  (set! (-> stmt db) db)
	  (set! (-> stmt executed) 1)
	  (set! (-> stmt terminated) 0)
	  (result TRUE)])))

(define-cproc sqlite3-open (path::<string>) :: <sqlite3-handle>
  (let* ([db::sqlite3*])
	(unless (== (sqlite3_open (Scm_GetString path) (& db)) SQLITE_OK)
	  (Scm_Error "OPEN ERROR"))
	(result db)))

(define-cproc sqlite3-escape-string (value::<string>)
  (let*  ([tmp::char* (sqlite3_mprintf "%q" (Scm_GetStringConst value))]
		  [res::ScmObj (SCM_MAKE_STR_COPYING tmp)])

    (sqlite3_free tmp)
    (result res)))

(define-cproc sqlite3-errmsg (db::<sqlite3-handle>)
  (call <const-cstring> "sqlite3_errmsg"))

(define-cproc sqlite3-last-insert-rowid (db::<sqlite3-handle>) :: <ulong>
  (sqlite3_last_insert_rowid db))

(define-cproc sqlite3-statement-p (obj) :: <boolean>
  (result (SCM_SQLITE3_STMT_P obj)))

;; (define-cproc sqlite3-closed-p (db::<sqlite3-handle>) :: <boolean>
(define-cproc sqlite3-closed-p (db) :: <boolean>
  (SCM_ASSERT (SCM_FOREIGN_POINTER_P db))
  (result (SCM_TRUEP
		   (Scm_ForeignPointerAttrGet (SCM_FOREIGN_POINTER db)
									  'closed? SCM_FALSE))))

(define-cproc sqlite3-statement-end? (stmt::<sqlite3-statement>) :: <boolean>
  (result (-> stmt terminated)))

(define-cproc sqlite3-statement-step (stmt::<sqlite3-statement>)
  (call "Sqlite3StmtStep"))

(define-cproc sqlite3-statement-closed-p (stmt::<sqlite3-statement>) :: <boolean>
  (let* ([handle::sqlite3_stmt* (-> stmt core)])
	(result (== handle NULL))))

(define-cproc sqlite3-statement-finish (stmt::<sqlite3-statement>) :: <boolean>
  (cond
   [(== (-> stmt core) NULL)
	(result FALSE)]
   [else
	(sqlite3_finalize (-> stmt core))
	(set! (-> stmt core) NULL)
	(result TRUE)]))

(define-cproc sqlite3-statement-column-names (stmt::<sqlite3-statement>)
  (let* ([num::int (sqlite3_column_count (-> stmt core))]
		 [i::int]
		 [res '()])
	(for ((set! i 0) (< i num) (pre++ i))
		 (let* ([val (SCM_MAKE_STR_COPYING (sqlite3_column_name (-> stmt core) i))])
		   (set! res (Scm_Cons val res))))
	(set! res (Scm_Reverse res))
	(result res)))


